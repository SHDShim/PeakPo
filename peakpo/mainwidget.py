#!/usr/bin/env python
# used to parse files more easily

from __future__ import with_statement
import sys
import os
import os.path
from PyQt5 import QtCore
from PyQt5 import QtGui
from PyQt5 import QtWidgets
# from collections import OrderedDict
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cmx
from matplotlib import colors
from matplotlib.ticker import MultipleLocator
from matplotlib.backend_bases import key_press_handler
import pickle
import time
import zipfile
# local modules
from qtd import Ui_MainWindow
from utils import undo_button_press
from utils import samefilename, make_filename, get_sorted_filelist, \
    find_from_filelist, dialog_savefile, xls_ucfitlist, xls_jlist, writechi
from utils import SpinBoxFixStyle
from ds_cake import DiffImg
# do not change the module structure for ds_jcpds and ds_powdiff for
# retro compatibility
from ds_jcpds import JCPDSplt, Session, UnitCell, convert_tth
from ds_powdiff import PatternPeakPo, get_DataSection
exec(open('./version.py').read())


class DesignerMainWindow(QtWidgets.QMainWindow, Ui_MainWindow):
    """
    Main window
    """

    def __init__(self, parent=None):
        # initialization of the superclass
        super(DesignerMainWindow, self).__init__(parent)
        self.setupUi(self)  # setup the GUI --> function generated by pyuic5
        version = "7.2.1"  # consider reading version number from a single file
        self.setWindowTitle("PeakPo ver. " + str(__version__))
        self.about()
        # get objects
        self.Pattern = None
        self.waterfallpatterns = []
        self.jlist = []
        self.ucfitlist = []
        self.DiffImg = None
        self.poni_filename = None
        #
        self.objColor = 'white'
        self.readSettings()
        # disable unsupported buttons
        # self.pushButton_ApplyMask.setEnabled(False)
        self.pushButton_MakeBasePtn.setEnabled(False)
        self.pushButton_BackToOriginal.setEnabled(False)
        self.pushButton_Reintegrate1D.setEnabled(False)
        self.pushButton_OuputCHI.setEnabled(False)
        # connecting events
        self.mpl.canvas.mpl_connect('button_press_event', self.read_plot)
        self.mpl.canvas.mpl_connect('key_press_event', self.on_key_press)
        # Tab: Main
        self.pushButton_NewBasePtn.clicked.connect(self.select_file)
        self.pushButton_PrevBasePtn.clicked.connect(
            lambda: self.goto_nextfile('previous'))
        self.pushButton_NextBasePtn.clicked.connect(
            lambda: self.goto_nextfile('next'))
        self.pushButton_LastBasePtn.clicked.connect(
            lambda: self.goto_nextfile('last'))
        self.pushButton_FirstBasePtn.clicked.connect(
            lambda: self.goto_nextfile('first'))
        self.radioButton_P01.clicked.connect(self.set_pstep)
        self.radioButton_P1.clicked.connect(self.set_pstep)
        self.radioButton_P10.clicked.connect(self.set_pstep)
        self.radioButton_P100.clicked.connect(self.set_pstep)
        self.radioButton_T1.clicked.connect(self.set_tstep)
        self.radioButton_T10.clicked.connect(self.set_tstep)
        self.radioButton_T100.clicked.connect(self.set_tstep)
        self.radioButton_T1000.clicked.connect(self.set_tstep)
        self.pushButton_RoomT.clicked.connect(lambda: self.set_temperature(300))
        self.pushButton_1000K.clicked.connect(
            lambda: self.set_temperature(1000))
        self.pushButton_1500K.clicked.connect(
            lambda: self.set_temperature(1500))
        self.pushButton_2000K.clicked.connect(
            lambda: self.set_temperature(2000))
        self.pushButton_2500K.clicked.connect(
            lambda: self.set_temperature(2500))
        self.pushButton_3000K.clicked.connect(
            lambda: self.set_temperature(3000))
        self.pushButton_3500K.clicked.connect(
            lambda: self.set_temperature(3500))
        self.pushButton_4000K.clicked.connect(
            lambda: self.set_temperature(4000))
        self.pushButton_4500K.clicked.connect(
            lambda: self.set_temperature(4500))
        self.pushButton_5000K.clicked.connect(
            lambda: self.set_temperature(5000))
        self.doubleSpinBox_Pressure.valueChanged.connect(self.apply_PTtoGraph)
        self.doubleSpinBox_Pressure.setKeyboardTracking(False)
        self.doubleSpinBox_Pressure.setStyle(SpinBoxFixStyle())
        self.doubleSpinBox_Temperature.valueChanged.connect(
            self.apply_PTtoGraph)
        self.doubleSpinBox_Temperature.setKeyboardTracking(False)
        self.doubleSpinBox_Temperature.setStyle(SpinBoxFixStyle())
        self.pushButton_SaveSession.clicked.connect(self.save_session)
        self.pushButton_LoadSession.clicked.connect(self.load_session)
        self.pushButton_ZipSession.clicked.connect(self.zip_session)
        self.checkBox_IntNorm.clicked.connect(self.norm_int)
        # Tab: waterfall
        self.pushButton_AddPatterns.clicked.connect(self.add_patterns)
        self.doubleSpinBox_WaterfallGaps.valueChanged.connect(
            self.apply_changestograph)
        self.doubleSpinBox_WaterfallGaps.setKeyboardTracking(False)
        self.doubleSpinBox_WaterfallGaps.setStyle(SpinBoxFixStyle())
        self.pushButton_CleanPatterns.clicked.connect(self.erase_waterfall)
        self.pushButton_RemovePatterns.clicked.connect(
            self.remove_waterfall)
        self.pushButton_UpPattern.clicked.connect(self.up_waterfall)
        self.pushButton_DownPattern.clicked.connect(self.down_waterfall)
        self.pushButton_ApplyWaterfallChange.clicked.connect(
            self.apply_changestograph)
        # Tab: process
        self.spinBox_BGParam0.setKeyboardTracking(False)
        self.spinBox_BGParam1.setKeyboardTracking(False)
        self.spinBox_BGParam2.setKeyboardTracking(False)
        self.spinBox_BGParam0.setStyle(SpinBoxFixStyle())
        self.spinBox_BGParam1.setStyle(SpinBoxFixStyle())
        self.spinBox_BGParam2.setStyle(SpinBoxFixStyle())
        self.doubleSpinBox_Background_ROI_max.setKeyboardTracking(False)
        self.doubleSpinBox_Background_ROI_min.setKeyboardTracking(False)
        self.doubleSpinBox_Background_ROI_max.setStyle(SpinBoxFixStyle())
        self.doubleSpinBox_Background_ROI_min.setStyle(SpinBoxFixStyle())
        self.pushButton_UpdatePlots_tab2.clicked.connect(self.update_bgsub)
        # Tab: JCPDS List
        self.pushButton_NewJlist.clicked.connect(self.make_jlist)
        self.pushButton_RemoveJCPDS.clicked.connect(self.remove_a_jcpds)
        self.pushButton_AddToJlist.clicked.connect(
            lambda: self.make_jlist(append=True))
        self.pushButton_SaveJlist.clicked.connect(self.save_session)
        self.pushButton_LoadJlist.clicked.connect(self.load_jlist)
        self.pushButton_ViewJCPDS.clicked.connect(self.view_jcpds)
        self.checkBox_Intensity.clicked.connect(self.apply_changestograph)
        self.doubleSpinBox_SetWavelength.valueChanged.connect(
            self.apply_wavelength)
        self.doubleSpinBox_SetWavelength.setKeyboardTracking(False)
        self.doubleSpinBox_SetWavelength.setStyle(SpinBoxFixStyle())
        self.pushButton_CheckAllJCPDS.clicked.connect(self.check_allJCPDS)
        self.pushButton_UncheckAllJCPDS.clicked.connect(
            self.uncheck_allJCPDS)
        self.pushButton_MoveUp.clicked.connect(self.moveup_JCPDS)
        self.pushButton_MoveDown.clicked.connect(self.movedown_JCPDS)
        self.pushButton_ExportXLS.clicked.connect(self.save_XLS)
        self.pushButton_SaveCHI.clicked.connect(self.save_bgsubchi)
        self.pushButton_ExportToUCFit.clicked.connect(self.export_toUCFit)
        # Tab: Cake
        self.pushButton_AddRemoveCake.clicked.connect(self.addremove_Cake)
        self.pushButton_GetPONI.clicked.connect(self.get_PONI)
        self.spinBox_VMin.setValue(100)
        self.spinBox_VMax.setValue(7000)
        self.pushButton_ApplyCakeView.clicked.connect(
            self.apply_changestograph)
        self.pushButton_ApplyMask.clicked.connect(self.apply_mask)
        self.spinBox_CakeAxisSize.setValue(50)
        # Tab: UCFit List
        self.pushButton_RemoveUClist.clicked.connect(self.remove_ucfit)
        self.pushButton_ExportXLS_2.clicked.connect(self.export_toXLS)
        # file menu items
        self.actionClose.triggered.connect(self.closeEvent)
        self.actionCiting_PeakPo.triggered.connect(self.about)
        self.actionShortcut_keys.triggered.connect(self.shortcutkeys)
        # navigation toolbar modification
        self.ntb_WholePtn = QtWidgets.QPushButton()
        self.ntb_WholePtn.setText("ZoomOut")
        self.mpl.ntb.addWidget(self.ntb_WholePtn)
        self.ntb_WholePtn.clicked.connect(self.update_graph2whole)
        #
        self.ntb_toPkFt = QtWidgets.QPushButton()
        self.ntb_toPkFt.setText("toPkFt")
        self.mpl.ntb.addWidget(self.ntb_toPkFt)
        self.ntb_toPkFt.clicked.connect(self.to_PkFt)
        #
        self.ntb_fromPkFt = QtWidgets.QPushButton()
        self.ntb_fromPkFt.setText("fromPkFt")
        self.mpl.ntb.addWidget(self.ntb_fromPkFt)
        self.ntb_fromPkFt.clicked.connect(self.from_PkFt)
        #
        self.ntb_ResetY = QtWidgets.QCheckBox()
        self.ntb_ResetY.setCheckable(True)
        self.ntb_ResetY.setChecked(False)
        self.ntb_ResetY.setText("AutoYScale")
        self.mpl.ntb.addWidget(self.ntb_ResetY)
        self.ntb_ResetY.clicked.connect(self.apply_changestograph)
        #
        self.ntb_Bgsub = QtWidgets.QCheckBox()
        self.ntb_Bgsub.setCheckable(True)
        self.ntb_Bgsub.setChecked(True)
        self.ntb_Bgsub.setText("BgSub")
        self.mpl.ntb.addWidget(self.ntb_Bgsub)
        self.ntb_Bgsub.clicked.connect(self.apply_changestograph)
        #
        self.ntb_NightView = QtWidgets.QCheckBox()
        self.ntb_NightView.setCheckable(True)
        self.ntb_NightView.setChecked(True)
        self.ntb_NightView.setText("Night")
        self.mpl.ntb.addWidget(self.ntb_NightView)
        self.ntb_NightView.clicked.connect(self.set_NightDayView)
        #
        self.clip = QtWidgets.QApplication.clipboard()
        # no more stuff can be added below

    def addremove_Cake(self):
        """
        Cake function
        Add/remove cake to the graph
        """
        if not self.pushButton_AddRemoveCake.isChecked():
            self.pushButton_AddRemoveCake.setText('Add Cake')
            self.update_graph()
            return
        else:
            self.pushButton_AddRemoveCake.setText('Remove Cake')
        if self.poni_filename is None:
            QtWidgets.QMessageBox.warning(
                self, 'Warning', 'Choose PONI file first.')
            undo_button_press(
                self.pushButton_AddRemoveCake,
                released_text='Add Cake', pressed_text='Remove Cake')
            return
        if self.Pattern is None:
            QtWidgets.QMessageBox.warning(
                self, 'Warning', 'Choose CHI file first.')
            undo_button_press(
                self.pushButton_AddRemoveCake,
                released_text='Add Cake', pressed_text='Remove Cake')
            return
        filen_tif = make_filename(self.Pattern.fname, 'tif')
        if not os.path.exists(filen_tif):
            QtWidgets.QMessageBox.warning(
                self, 'Warning',
                'Cannot find %s.' % filen_tif)
            undo_button_press(
                self.pushButton_AddRemoveCake,
                released_text='Add Cake', pressed_text='Remove Cake')
            return
        if (self.DiffImg is not None) and \
                (samefilename(self.Pattern.fname, self.DiffImg.img_filename)):
            self.update_graph()
            return
        self._load_new_image(filen_tif)
        self._update_cake()
        self.update_graph()

    def _load_new_image(self, filen_tif):
        """
        Cake function
        Load new image for cake view.  Cake should be the same as base pattern.
        """
        self.DiffImg = DiffImg()
        self.DiffImg.load(filen_tif)
        self.label_DiffractionImageFilename.setText(
            '2D Image: ' + filen_tif)

    def apply_mask(self):
        self._update_cake()
        self.update_graph()

    def _update_cake(self):
        """
        Cake function
        Reprocess to get cake.  Slower re-processing
        """
        self.DiffImg.set_calibration(self.poni_filename)
        self.DiffImg.set_mask((self.spinBox_MaskMin.value(),
                               self.spinBox_MaskMax.value()))
        self.DiffImg.integrate_to_cake()
        intensity_cake, tth_cake, chi_cake = self.DiffImg.get_cake()
        self.intensity_cake = intensity_cake
        self.tth_cake = tth_cake
        self.chi_cake = chi_cake

    def get_PONI(self):
        """
        Cake function
        Opens a pyFAI calibration file
        """
        file = QtWidgets.QFileDialog.getOpenFileName(
            self, "Open a PONI File",
            self.chi_path, "PONI files (*.poni)")[0]
        if os.path.exists(str(file)):
            poni_path, dum = os.path.split(str(file))
            # I am unsure poni_path would be needed to be self
            self.poni_path = poni_path
            self.poni_filename = str(file)
            self.label_PONI.setText('PONI: ' + self.poni_filename)
            if self.DiffImg is not None:
                self._update_cake()
            self.update_graph()

    def norm_int(self):
        """
        Waterfall function
        Need documentation for its function
        """
        if self.waterfallpatterns == []:
            return
        count = 0
        for wf in self.waterfallpatterns:
            if wf.display:
                count += 1
        if count == 0:
            return
        # update figure
        self.update_graph()
        return

    def export_toXLS(self):
        """
        UCFit function
        Export ucfitlist to an excel file
        """
        if self.ucfitlist == []:
            return
        new_filen_xls = make_filename(self.Pattern.fname, 'peakpo.ucfit.xls')
        filen_xls = dialog_savefile(self, new_filen_xls)
        if str(filen_xls) == '':
            return
        xls_ucfitlist(filen_xls, self.ucfitlist)

    def remove_ucfit(self):
        """
        UCFit function
        Remove items from the ucfitlist
        """
        reply = QtWidgets.QMessageBox.question(
            self, 'Message',
            'Are you sure you want to remove the highlighted phases?',
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.Yes)
        if reply == QtWidgets.QMessageBox.No:
            return
        idx_checked = []
        for item in self.tableWidget_UnitCell.selectedIndexes():
            if item.column() != 1:
                return
            else:
                idx_checked.append(item.row())
        if idx_checked != []:
            idx_checked.reverse()
            for idx in idx_checked:
                self.ucfitlist.remove(self.ucfitlist[idx])
                self.tableWidget_UnitCell.removeRow(idx)
            self.update_graph()
        else:
            QtWidgets.QMessageBox.warning(
                self, 'Warning', 'In order to remove, highlight the names.')

    def export_toUCFit(self):
        """
        UCFit function
        Export an item from jlist to ucfitlist
        """
        if self.jlist == []:
            return
        idx_checked = []
        for item in self.tableWidget_JCPDS.selectedIndexes():
            if item.column() != 1:
                QtWidgets.QMessageBox.warning(
                    self, "Warning", "Highlight the name of JCPDS to export")
                return
            else:
                self.jlist[item.row()].display = False
                idx_checked.append(item.row())
        i = 0
        for j in range(idx_checked.__len__()):
            if self.jlist[idx_checked[j]].symmetry != 'manual':
                phase = UnitCell()
                phase.name = self.jlist[idx_checked[j]].name
                phase.color = self.jlist[idx_checked[j]].color
                phase.symmetry = self.jlist[idx_checked[j]].symmetry
                phase.a = self.jlist[idx_checked[j]].a
                phase.b = self.jlist[idx_checked[j]].b
                phase.c = self.jlist[idx_checked[j]].c
                phase.alpha = self.jlist[idx_checked[j]].alpha
                phase.beta = self.jlist[idx_checked[j]].beta
                phase.gamma = self.jlist[idx_checked[j]].gamma
                phase.v = self.jlist[idx_checked[j]].v
                phase.DiffLines = self.jlist[idx_checked[j]].DiffLines
                self.ucfitlist.append(phase)
                i += 1
            else:
                QtWidgets.QMessageBox.warning(
                    self, "Warning",
                    "You cannot send a jcpds without symmetry.")
        self._list_ucfit()
        self._list_jcpds()
        self.update_graph()
        return

    def _list_ucfit(self):
        """
        UCFit function
        Show ucfit in the QTableWidget
        """
        n_columns = 11
        n_rows = self.ucfitlist.__len__()  # count for number of jcpds
        self.tableWidget_UnitCell.setColumnCount(n_columns)
        self.tableWidget_UnitCell.setRowCount(n_rows)
        self.tableWidget_UnitCell.horizontalHeader().setVisible(True)
        self.tableWidget_UnitCell.verticalHeader().setVisible(True)
        self.tableWidget_UnitCell.setHorizontalHeaderLabels(
            ['', 'Name', 'Color', 'Color Change', 'Volume', 'a', 'b', 'c',
             'alpha', 'beta', 'gamma'])
        for row in range(n_rows):
            # column 0 - checkbox
            item0 = QtWidgets.QTableWidgetItem()
            item0.setFlags(
                QtCore.Qt.ItemIsUserCheckable | QtCore.Qt.ItemIsEnabled)
            if self.ucfitlist[row].display:
                item0.setCheckState(QtCore.Qt.Checked)
            else:
                item0.setCheckState(QtCore.Qt.Unchecked)
            self.tableWidget_UnitCell.setItem(row, 0, item0)
            # column 1 - name
            item1 = QtWidgets.QTableWidgetItem(self.ucfitlist[row].name)
            self.tableWidget_UnitCell.setItem(row, 1, item1)
            # column 2 - color
            item2 = QtWidgets.QTableWidgetItem('    ')
            self.tableWidget_UnitCell.setItem(row, 2, item2)
            # column 3 - color setup
            self.tableWidget_UnitCell_pushButton_color = QtWidgets.QPushButton('change')
            self.tableWidget_UnitCell.item(row, 2).setBackground(
                QtGui.QColor(self.ucfitlist[row].color))
            self.tableWidget_UnitCell_pushButton_color.clicked.connect(
                self._ucfitlist_handle_ColorButtonClicked)
            self.tableWidget_UnitCell.setCellWidget(
                row, 3, self.tableWidget_UnitCell_pushButton_color)
            # column 4 - V output
            self.ucfitlist[row].cal_dsp()
            Item4 = QtWidgets.QTableWidgetItem(
                "{:.3f}".format(float(self.ucfitlist[row].v)))
            Item4.setFlags(QtCore.Qt.ItemIsSelectable |
                           QtCore.Qt.ItemIsEnabled)
            self.tableWidget_UnitCell.setItem(row, 4, Item4)
            # column 5 - a
            self.tableWidget_UnitCell_doubleSpinBox_a = QtWidgets.QDoubleSpinBox()
            self.tableWidget_UnitCell_doubleSpinBox_a.setAlignment(
                QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing |
                QtCore.Qt.AlignVCenter)
            self.tableWidget_UnitCell_doubleSpinBox_a.setMaximum(50.0)
            self.tableWidget_UnitCell_doubleSpinBox_a.setSingleStep(0.001)
            self.tableWidget_UnitCell_doubleSpinBox_a.setDecimals(4)
            self.tableWidget_UnitCell_doubleSpinBox_a.setProperty(
                "value", float(self.ucfitlist[row].a))
            self.tableWidget_UnitCell_doubleSpinBox_a.valueChanged.connect(
                self._ucfitlist_handle_doubleSpinBoxChanged)
            self.tableWidget_UnitCell_doubleSpinBox_a.setStyle(
                SpinBoxFixStyle())
            self.tableWidget_UnitCell.setCellWidget(
                row, 5, self.tableWidget_UnitCell_doubleSpinBox_a)
            self.tableWidget_UnitCell_doubleSpinBox_a.setKeyboardTracking(
                False)
            self.tableWidget_UnitCell_doubleSpinBox_a.setFocusPolicy(
                QtCore.Qt.StrongFocus)
            # column 6 - b output
            if (self.ucfitlist[row].symmetry == 'cubic') or\
                    (self.ucfitlist[row].symmetry == 'tetragonal') or\
                    (self.ucfitlist[row].symmetry == 'hexagonal'):
                item6 = QtWidgets.QTableWidgetItem('')
                item6.setFlags(QtCore.Qt.ItemIsEnabled)
                self.tableWidget_UnitCell.setItem(row, 6, item6)
            else:
                self.tableWidget_UnitCell_doubleSpinBox_b = QtWidgets.QDoubleSpinBox()
                self.tableWidget_UnitCell_doubleSpinBox_b.setAlignment(
                    QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing |
                    QtCore.Qt.AlignVCenter)
                self.tableWidget_UnitCell_doubleSpinBox_b.setMaximum(50.0)
                self.tableWidget_UnitCell_doubleSpinBox_b.setSingleStep(
                    0.001)
                self.tableWidget_UnitCell_doubleSpinBox_b.setDecimals(4)
                self.tableWidget_UnitCell_doubleSpinBox_b.setProperty(
                    "value", float(self.ucfitlist[row].b))
                self.tableWidget_UnitCell_doubleSpinBox_b.valueChanged.\
                    connect(
                        self._ucfitlist_handle_doubleSpinBoxChanged)
                self.tableWidget_UnitCell_doubleSpinBox_b.setStyle(
                    SpinBoxFixStyle())
                self.tableWidget_UnitCell.setCellWidget(
                    row, 6, self.tableWidget_UnitCell_doubleSpinBox_b)
                self.tableWidget_UnitCell_doubleSpinBox_b.\
                    setKeyboardTracking(False)
                self.tableWidget_UnitCell_doubleSpinBox_b.setFocusPolicy(
                    QtCore.Qt.StrongFocus)
            # column 7 - c output
            if (self.ucfitlist[row].symmetry == 'cubic'):
                item7 = QtWidgets.QTableWidgetItem('')
                item7.setFlags(QtCore.Qt.ItemIsEnabled)
                self.tableWidget_UnitCell.setItem(row, 7, item7)
            else:
                self.tableWidget_UnitCell_doubleSpinBox_c = QtWidgets.QDoubleSpinBox()
                self.tableWidget_UnitCell_doubleSpinBox_c.setAlignment(
                    QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing |
                    QtCore.Qt.AlignVCenter)
                self.tableWidget_UnitCell_doubleSpinBox_c.setMaximum(50.0)
                self.tableWidget_UnitCell_doubleSpinBox_c.setSingleStep(
                    0.001)
                self.tableWidget_UnitCell_doubleSpinBox_c.setDecimals(4)
                self.tableWidget_UnitCell_doubleSpinBox_c.setProperty(
                    "value", float(self.ucfitlist[row].c))
                self.tableWidget_UnitCell_doubleSpinBox_c.valueChanged.\
                    connect(self._ucfitlist_handle_doubleSpinBoxChanged)
                self.tableWidget_UnitCell_doubleSpinBox_c.setStyle(
                    SpinBoxFixStyle())
                self.tableWidget_UnitCell.setCellWidget(
                    row, 7, self.tableWidget_UnitCell_doubleSpinBox_c)
                self.tableWidget_UnitCell_doubleSpinBox_c.\
                    setKeyboardTracking(False)
                self.tableWidget_UnitCell_doubleSpinBox_c.setFocusPolicy(
                    QtCore.Qt.StrongFocus)
            # column 8 - alpha output
            if not (self.ucfitlist[row].symmetry == 'triclinic'):
                item8 = QtWidgets.QTableWidgetItem('90.')
                item8.setFlags(QtCore.Qt.ItemIsEnabled)
                self.tableWidget_UnitCell.setItem(row, 8, item8)
            else:
                self.tableWidget_UnitCell_doubleSpinBox_alpha = QtWidgets.QDoubleSpinBox()
                self.tableWidget_UnitCell_doubleSpinBox_alpha.setAlignment(
                    QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing |
                    QtCore.Qt.AlignVCenter)
                self.tableWidget_UnitCell_doubleSpinBox_alpha.setMaximum(
                    179.0)
                self.tableWidget_UnitCell_doubleSpinBox_alpha.setSingleStep(
                    0.1)
                self.tableWidget_UnitCell_doubleSpinBox_alpha.setDecimals(1)
                self.tableWidget_UnitCell_doubleSpinBox_alpha.setProperty(
                    "value", float(self.ucfitlist[row].alpha))
                self.tableWidget_UnitCell_doubleSpinBox_alpha.valueChanged.\
                    connect(self._ucfitlist_handle_doubleSpinBoxChanged)
                self.tableWidget_UnitCell_doubleSpinBox_alpha.setStyle(
                    SpinBoxFixStyle())
                self.tableWidget_UnitCell.setCellWidget(
                    row, 8, self.tableWidget_UnitCell_doubleSpinBox_alpha)
                self.tableWidget_UnitCell_doubleSpinBox_alpha.\
                    setKeyboardTracking(False)
                self.tableWidget_UnitCell_doubleSpinBox_alpha.setFocusPolicy(
                    QtCore.Qt.StrongFocus)
            # column 9 - beta output
            if (self.ucfitlist[row].symmetry == 'cubic') or \
                    (self.ucfitlist[row].symmetry == 'tetragonal') or\
                    (self.ucfitlist[row].symmetry == 'hexagonal') or\
                    (self.ucfitlist[row].symmetry == 'orthorhombic'):
                item9 = QtWidgets.QTableWidgetItem('90.')
                item9.setFlags(QtCore.Qt.ItemIsEnabled)
                self.tableWidget_UnitCell.setItem(row, 9, item9)
            else:
                self.tableWidget_UnitCell_doubleSpinBox_beta = QtWidgets.QDoubleSpinBox()
                self.tableWidget_UnitCell_doubleSpinBox_beta.setAlignment(
                    QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing |
                    QtCore.Qt.AlignVCenter)
                self.tableWidget_UnitCell_doubleSpinBox_beta.setMaximum(
                    179.0)
                self.tableWidget_UnitCell_doubleSpinBox_beta.setSingleStep(
                    0.1)
                self.tableWidget_UnitCell_doubleSpinBox_beta.setDecimals(1)
                self.tableWidget_UnitCell_doubleSpinBox_beta.setProperty(
                    "value", float(self.ucfitlist[row].beta))
                self.tableWidget_UnitCell_doubleSpinBox_beta.valueChanged.\
                    connect(self._ucfitlist_handle_doubleSpinBoxChanged)
                self.tableWidget_UnitCell_doubleSpinBox_beta.setStyle(
                    SpinBoxFixStyle())
                self.tableWidget_UnitCell.setCellWidget(
                    row, 9, self.tableWidget_UnitCell_doubleSpinBox_beta)
                self.tableWidget_UnitCell_doubleSpinBox_beta.\
                    setKeyboardTracking(False)
                self.tableWidget_UnitCell_doubleSpinBox_beta.setFocusPolicy(
                    QtCore.Qt.StrongFocus)
            # column 10 - gamma output
            if not (self.ucfitlist[row].symmetry == 'triclinic'):
                if self.ucfitlist[row].symmetry == 'hexagonal':
                    item10 = QtWidgets.QTableWidgetItem('120.')
                else:
                    item10 = QtWidgets.QTableWidgetItem('90.')
                item10.setFlags(QtCore.Qt.ItemIsEnabled)
                self.tableWidget_UnitCell.setItem(row, 10, item10)
            else:
                self.tableWidget_UnitCell_doubleSpinBox_gamma = QtWidgets.QDoubleSpinBox()
                self.tableWidget_UnitCell_doubleSpinBox_gamma.setAlignment(
                    QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing |
                    QtCore.Qt.AlignVCenter)
                self.tableWidget_UnitCell_doubleSpinBox_gamma.setMaximum(
                    179.0)
                self.tableWidget_UnitCell_doubleSpinBox_gamma.setSingleStep(
                    0.1)
                self.tableWidget_UnitCell_doubleSpinBox_gamma.setDecimals(1)
                self.tableWidget_UnitCell_doubleSpinBox_gamma.setProperty(
                    "value", float(self.ucfitlist[row].gamma))
                self.tableWidget_UnitCell_doubleSpinBox_gamma.\
                    valueChanged.connect(
                        self._ucfitlist_handle_doubleSpinBoxChanged)
                self.tableWidget_UnitCell_doubleSpinBox_gamma.setStyle(
                    SpinBoxFixStyle())
                self.tableWidget_UnitCell.setCellWidget(
                    row, 10, self.tableWidget_UnitCell_doubleSpinBox_gamma)
                self.tableWidget_UnitCell_doubleSpinBox_gamma.\
                    setKeyboardTracking(False)
                self.tableWidget_UnitCell_doubleSpinBox_gamma.setFocusPolicy(
                    QtCore.Qt.StrongFocus)
        self.tableWidget_UnitCell.resizeColumnsToContents()
#        self.tableWidget_UnitCell.resizeRowsToContents()
        self.tableWidget_UnitCell.itemClicked.connect(
            self._ucfitlist_handle_ItemClicked)

    def _ucfitlist_handle_doubleSpinBoxChanged(self, value):
        box = self.sender()
        index = self.tableWidget_UnitCell.indexAt(box.pos())
        if index.isValid():
            idx = index.row()
            if index.column() == 5:
                self.ucfitlist[idx].a = value
                if self.ucfitlist[idx].symmetry == 'cubic':
                    self.ucfitlist[idx].b = value
                    self.ucfitlist[idx].c = value
                elif (self.ucfitlist[idx].symmetry == 'tetragonal') or \
                        (self.ucfitlist[idx].symmetry == 'hexagonal'):
                    self.ucfitlist[idx].b = value
                else:
                    pass
            elif index.column() == 6:
                self.ucfitlist[idx].b = value
            elif index.column() == 7:
                self.ucfitlist[idx].c = value
            elif index.column() == 8:
                self.ucfitlist[idx].alpha = value
            elif index.column() == 9:
                self.ucfitlist[idx].beta = value
            elif index.column() == 10:
                self.ucfitlist[idx].gamma = value
            if self.ucfitlist[idx].display:
                self.update_graph()

    def _ucfitlist_handle_ColorButtonClicked(self):
        button = self.sender()
        index = self.tableWidget_UnitCell.indexAt(button.pos())
        if index.isValid():
            idx = index.row()
            if index.column() == 3:
                color = QtWidgets.QColorDialog.getColor()
                if color.isValid():
                    self.tableWidget_UnitCell.item(idx, 2).\
                        setBackground(color)
                    self.ucfitlist[idx].color = str(color.name())
                    self.update_graph()

    def _ucfitlist_handle_ItemClicked(self, item):
        if item.column() == 0:
            idx = item.row()
            if (item.checkState() == QtCore.Qt.Checked) == \
                    self.ucfitlist[idx].display:
                return
            if item.checkState() == QtCore.Qt.Checked:
                self.ucfitlist[idx].display = True
            elif item.checkState() == QtCore.Qt.Unchecked:
                self.ucfitlist[idx].display = False
            self.update_graph()
        else:
            return

    def save_bgsubchi(self):
        """
        Output function
        Save bg subtractd pattern to a chi file
        """
        if self.Pattern is None:
            return
        filen_chi_t = make_filename(self.Pattern.fname, '.bgsub.chi')
        filen_chi = dialog_savefile(self, filen_chi_t)
        if str(filen_chi) == '':
            return
        x, y = self.Pattern.get_bgsub()
        writechi(filen_chi, x, y)

    def writeSettings(self):
        """
        Write default setting
        """
        self.settings = QtCore.QSettings('DS', 'PeakPo')
        self.settings.setValue('chi_path', self.chi_path)
        self.settings.setValue('jcpds_path', self.jcpds_path)

    def readSettings(self):
        """
        Read default setting
        """
        self.settings = QtCore.QSettings('DS', 'PeakPo')
        self.chi_path = str(self.settings.value('chi_path'))
        self.jcpds_path = str(self.settings.value('jcpds_path'))

    def closeEvent(self, event):
        """
        Close event function
        """
        self.writeSettings()
        self.deleteLater()
        """
        # begin wheel turn off
        QtWidgets.QApplication.instance().removeEventFilter(self)
        return super(DesignerMainWindow, self).closeEvent(event)
        # end wheel turn off
        """

    def on_key_press(self, event):
        #        print event.key
        if event.key == 'i':
            if self.mpl.ntb._active == 'PAN':
                self.mpl.ntb.pan()
            if self.mpl.ntb._active == 'ZOOM':
                self.mpl.ntb.zoom()
        elif event.key == 's':
            self.save_session_fast()
        elif event.key == 'w':
            self.update_graph2whole()
        elif event.key == 'v':
            lims = self.mpl.canvas.ax.axis()
            if self.ntb_Bgsub.isChecked():
                x, y = self.Pattern.get_bgsub()
            else:
                x, y = self.Pattern.get_raw()
            xroi, yroi = get_DataSection(x, y, [lims[0], lims[1]])
            self.update_graph([lims[0], lims[1], yroi.min(), yroi.max()])
        else:
            key_press_handler(event, self.mpl.canvas, self.mpl.ntb)

    def shortcutkeys(self):
        QtWidgets.QMessageBox.about(
            self, 'Shortcut Keys',
            'Save session: s<br>' +
            'Rescale vertical: v<br>' +
            'Whole spectrum: w<br>' +
            'Home or Reset: H or R<br>' +
            'Back: left arrow<br>' +
            'Forward: right arrow<br>' +
            'Pan: p<br>' +
            'Zoom: o<br>' +
            'Peak position read: i<br>' +
            'Constrain pan/zoom to x axis: hold x when panning/zooming<br>' +
            'Constrain pan/zoom to y axis: hold y when panning/zooming<br>' +
            'Preserve aspect ratio: hold CTRL when panning/zooming<br>' +
            'Toggle x scale (log/lin): L or k when mouse is over an axes<br>' +
            'Toggle y scale (log/lin): l when mouse is over an axes<br>')

    def to_PkFt(self):
        # listen
        if self.Pattern is None:
            return
        lims = self.mpl.canvas.ax.axis()
        talk = "PeakPo,{0},{1: .2f},{2: .2f},{3: .2f},{4: .2f}".format(
            self.Pattern.fname, lims[0], lims[1], lims[2], lims[3])
        self.clip.setText(talk)

    def from_PkFt(self):
        l = self.clip.text()
        listen = str(l)
        if listen.find("PeakFt") == -1:
            return
        a = listen.split(',')
        new_filen = a[1]
        new_lims = [float(i) for i in a[2:6]]
        self._read_a_newpattern(new_filen)
        self.update_graph(new_lims)

    def save_XLS(self):
        """
        JCPDS function
        Export jlist to an excel file
        """
        if self.jlist == []:
            return
        filen_xls_t = make_filename(self.Pattern.fname, 'pkpo.xls')
        filen_xls = dialog_savefile(self, filen_xls_t)
        if str(filen_xls) == '':
            return
        xls_jlist(filen_xls, self.jlist, self.doubleSpinBox_Pressure.value(),
                  self.doubleSpinBox_Temperature.value())

    def _find_a_JCPDS(self):
        idx_checked = []
        for item in self.tableWidget_JCPDS.selectedIndexes():
            if item.column() != 1:
                return None
            else:
                idx_checked.append(item.row())
        return idx_checked[0]

    def _find_a_wf(self):
        idx_checked = []
        for item in self.tableWidget_wfPatterns.selectedIndexes():
            if item.column() != 1:
                return None
            else:
                idx_checked.append(item.row())
        return idx_checked[0]

    def moveup_JCPDS(self):
        # get selected cell number
        idx_selected = self._find_a_JCPDS()
        if idx_selected is None:
            QtWidgets.QMessageBox.warning(self, "Warning",
                                          "Highlight the item to move first.")
            return
        i = idx_selected
        self.jlist[i - 1], self.jlist[i] = self.jlist[i], self.jlist[i - 1]
        self.tableWidget_JCPDS.setCurrentItem(
            self.tableWidget_JCPDS.item(i - 1, 1))
        # self.tableWidget_JCPDS.setCurrentItem(
        #    self.tableWidget_JCPDS.item(i, 1), False)
        """
        self.tableWidget_JCPDS.setItemSelected(
            self.tableWidget_JCPDS.item(i - 1, 1), True)
        self.tableWidget_JCPDS.setItemSelected(
            self.tableWidget_JCPDS.item(i, 1), False)
        """
        self._list_jcpds()

    def movedown_JCPDS(self):
        # get selected cell number
        idx_selected = self._find_a_JCPDS()
        if idx_selected is None:
            QtWidgets.QMessageBox.warning(self, "Warning",
                                          "Highlight the item to move first.")
            return
        i = idx_selected
        self.jlist[i + 1], self.jlist[i] = self.jlist[i], self.jlist[i + 1]
        self.tableWidget_JCPDS.setCurrentItem(
            self.tableWidget_JCPDS.item(i + 1, 1))
        """
        self.tableWidget_JCPDS.setItemSelected(
            self.tableWidget_JCPDS.item(i + 1, 1), True)
        self.tableWidget_JCPDS.setItemSelected(
            self.tableWidget_JCPDS.item(i, 1), False)
        """
        self._list_jcpds()

    def check_allJCPDS(self):
        if self.jlist == []:
            return
        for j in self.jlist:
            j.display = True
        self._list_jcpds()
        self.update_graph()

    def uncheck_allJCPDS(self):
        if self.jlist == []:
            return
        for j in self.jlist:
            j.display = False
        self._list_jcpds()
        self.update_graph()

    def load_session(self):
        """get existing jlist file from data folder"""
        fn = QtWidgets.QFileDialog.getOpenFileName(
            self, "Choose A Session File", self.chi_path, "(*.ppss)")[0]
#       replaceing chi_path with '' does not work
        if fn == '':
            return
        success = self._load_session(fn, False)
        if success:
            self.label_Jlist.setText(
                'Jlist: ' + os.path.basename(str(fn)))
            self.label_SessionFileName.setText(
                'Session: ' + os.path.basename(str(fn)))
            self.update_graph2whole()
            self.update_inputs()

    def _update_session(self):
        if self.Pattern.fname is None:
            return
        fn = make_filename(self.Pattern.fname, 'ppss')
        if not os.path.exists(fn):
            return
        success = self._load_session(fn, False)
        if success:
            self.label_Jlist.setText(
                'JCPDS list from: ' + os.path.basename(str(fn)))
            self.label_SessionFileName.setText(
                'Session information from: ' + os.path.basename(str(fn)))
            self.update_inputs()

    def _load_session(self, fsession, jlistonly=False):
        '''internal method for reading pickled ppss file'''
#        session = Session()
#        try:
        f = open(fsession, 'rb')
        session = pickle.load(f, encoding='latin1')
#        print type(session).__name__
#        if type(session).__name__ == 'Session':
#            QtGui.QMessageBox.warning(self, 'Warning',
#                'This PPSS file has an old format.
#               Make sure you overwrite the file again after opening.')
        f.close()
        # except:
        #     QtGui.QMessageBox.warning(self, "Warning", \
        #         "Session loading failed.  But no harm, just inconvenience.")
        #     return False
        # through check of the file existence
        if jlistonly:
            self.jlist = session.jlist
            self.jcpds_path = session.jcpds_path
        else:
            if (session.chi_path != ''):
                if not os.path.exists(session.chi_path):
                    chi_path = os.path.dirname(str(fsession))
                    chi_basefilen = os.path.basename(session.pattern.fname)
                    chi_filen = os.path.join(chi_path, chi_basefilen)
                    if os.path.exists(chi_filen):
                        session.pattern.read_file(chi_filen)
                        session.pattern.get_chbg(
                            session.bg_roi, session.bg_params, yshift=0)
                        session.chi_path = chi_path
                    else:
                        QtWidgets.QMessageBox.warning(
                            self, "Warning",
                            "The base file in the PPSS cannot be found.")
                        return False
                    if session.waterfallpatterns != []:
                        for wfp in session.waterfallpatterns:
                            wfp_basefilen = os.path.basename(wfp.fname)
                            chi_filen = os.path.join(chi_path, wfp_basefilen)
                            if os.path.exists(chi_filen):
                                wfp.read_file(chi_filen)
                                wfp.get_chbg(session.bg_roi, session.bg_params,
                                             yshift=0)
                            else:
                                reply = QtWidgets.QMessageBox.question(
                                    self,
                                    "Question",
                                    "The waterfall files in the PPSS cannot \
                                    be found. Do you want to ignore the water \
                                    fall?",
                                    QtWidgets.QMessageBox.Yes |
                                    QtWidgets.QMessageBox.No,
                                    QtWidgets.QMessageBox.Yes)
                                if reply == QtWidgets.QMessageBox.Yes:
                                    session.waterfallpatterns = []
                                    break
                                else:
                                    return False
            if (session.jcpds_path != ''):
                if not os.path.exists(session.jcpds_path):
                    reply = QtWidgets.QMessageBox.question(
                        self,
                        "Question",
                        "The JCPDS path in the PPSS does not exist.  \
                        Do you want to update the JCPDS path?",
                        QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                        QtWidgets.QMessageBox.Yes)
                    if reply == QtWidgets.QMessageBox.Yes:
                        jcpds_path = QtWidgets.QFileDialog.getExistingDirectory(
                            self, "Open Directory", self.jcpds_path,
                            QtWidgets.QFileDialog.ShowDirsOnly)
                        if jcpds_path != '':
                            session.jcpds_path = jcpds_path
                        else:
                            return False
                    else:
                        QtWidgets.QMessageBox.warning(self, "Warning",
                                                      "PPSS read failed.")
                        return False
            if (session.pattern is None):
                if not os.path.exists(session.jcpds_path):
                    QtWidgets.QMessageBox.warning(
                        self, "Warning",
                        "No base pattern exists in the previous session.")
                    return False
            self.Pattern = session.pattern
            self.waterfallpatterns = session.waterfallpatterns
            self.doubleSpinBox_SetWavelength.setValue(session.wavelength)
            self.doubleSpinBox_Pressure.setValue(session.pressure)
            self.doubleSpinBox_Temperature.setValue(session.temperature)
            self.jlist = session.jlist
            self.doubleSpinBox_Background_ROI_min.setValue(
                session.bg_roi[0])
            self.doubleSpinBox_Background_ROI_max.setValue(
                session.bg_roi[1])
            self.spinBox_BGParam0.setValue(session.bg_params[0])
            self.spinBox_BGParam1.setValue(session.bg_params[1])
            self.spinBox_BGParam2.setValue(session.bg_params[2])
            self.jcpds_path = session.jcpds_path
            self.chi_path = session.chi_path
        return True

    def _dump_session(self, fsession):
        session = Session()
        session.pattern = self.Pattern
        session.waterfallpatterns = self.waterfallpatterns
        session.wavelength = self.doubleSpinBox_SetWavelength.value()
        session.pressure = self.doubleSpinBox_Pressure.value()
        session.temperature = self.doubleSpinBox_Temperature.value()
        session.jlist = self.jlist
        session.bg_roi = [self.doubleSpinBox_Background_ROI_min.value(),
                          self.doubleSpinBox_Background_ROI_max.value()]
        session.bg_params = [self.spinBox_BGParam0.value(),
                             self.spinBox_BGParam1.value(),
                             self.spinBox_BGParam2.value()]
        session.jcpds_path = self.jcpds_path
        session.chi_path = self.chi_path
        f = open(fsession, 'wb')
        pickle.dump(session, f)
        f.close()

    def update_inputs(self):
        # self.doubleSpinBox_Pressure.setValue(self.pressure)
        # self.doubleSpinBox_Temperature.setValue(self.temperature)
        self.reset_bgsub()
        self._list_wfpatterns()
        self._list_jcpds()
        # self.doubleSpinBox_SetWavelength.setValue(self.wavelength)

    def zip_session(self):
        if self.Pattern is None:
            fzip = os.path.join(self.chi_path, 'dum.zip')
        else:
            path, filen = os.path.split(self.Pattern.fname)
            new_filen = '%s.zip' % filen
            fzip = os.path.join(path, new_filen)
        reply = QtWidgets.QMessageBox.question(
            self, 'Question',
            'Do you want to save in default filename, %s ?' % fzip,
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.Yes)
        if reply == QtWidgets.QMessageBox.No:
            fzip = QtWidgets.QFileDialog.getSaveFileName(
                self, "Save A Zip File",
                fzip, "(*.zip)", None)[0]
        else:
            if os.path.exists(fzip):
                reply = QtWidgets.QMessageBox.question(
                    self, 'Question',
                    'The file already exist.  Do you want to overwrite?',
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                    QtWidgets.QMessageBox.No)
                if reply == QtWidgets.QMessageBox.No:
                    return
        if str(fzip) != '':
            path, filen = os.path.split(str(fzip))
            fsession_name = '%s.forzip.ppss' % filen
            fsession = os.path.join(path, fsession_name)
            self._dump_session(str(fsession))
            self.label_Jlist.setText('JCPDS list from: ' +
                                     os.path.basename(str(fsession)))
            zf = zipfile.ZipFile(str(fzip), 'w', zipfile.ZIP_DEFLATED)
            zf.write(fsession, arcname=fsession_name)
            if self.Pattern is not None:
                dum, filen = os.path.split(self.Pattern.fname)
                zf.write(self.Pattern.fname, arcname=filen)
            if self.waterfallpatterns != []:
                for wf in self.waterfallpatterns:
                    dum, filen = os.path.split(wf.fname)
                    zf.write(wf.fname, arcname=filen)
            zf.close()

    def save_session(self):
        if self.Pattern is None:
            fsession = os.path.join(self.chi_path, 'dum.ppss')
        else:
            fsession = make_filename(self.Pattern.fname, 'ppss')
        new_filename = dialog_savefile(self, fsession)
        if new_filename != '':
            self._dump_session(new_filename)
            self.label_SessionFileName.setText(
                'Session file (including jlist): ' +
                os.path.basename(new_filename))

    def save_session_fast(self):
        if self.Pattern is None:
            fsession = os.path.join(self.chi_path, 'dum.ppss')
        else:
            path, filen = os.path.split(self.Pattern.fname)
            new_filen = '%s.ppss' % filen
            fsession = os.path.join(path, new_filen)
        if os.path.exists(fsession):
            reply = QtWidgets.QMessageBox.question(
                self, 'Question',
                'The file already exist.  Do you want to overwrite?',
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                QtWidgets.QMessageBox.Yes)
            if reply == QtWidgets.QMessageBox.No:
                return
        if str(fsession) != '':
            self._dump_session(str(fsession))
            self.label_SessionFileName.setText(
                'Session file (including jlist): ' +
                os.path.basename(fsession))

    def set_NightDayView(self):
        self._set_NightDayView()
        self._list_wfpatterns()
        self.update_graph()

    def _set_NightDayView(self):
        if not self.ntb_NightView.isChecked():
            self.mpl.canvas.set_toNight(False)
            # reset plot objects with white
            if self.Pattern is not None:
                self.Pattern.color = 'k'
            if self.waterfallpatterns != []:
                for pattern in self.waterfallpatterns:
                    if (pattern.color == 'white') or \
                            (pattern.color == '#ffffff'):
                        pattern.color = 'k'
            self.objColor = 'k'
        else:
            self.mpl.canvas.set_toNight(True)
            if self.Pattern is not None:
                self.Pattern.color = 'white'
            if self.waterfallpatterns != []:
                for pattern in self.waterfallpatterns:
                    if (pattern.color == 'k') or (pattern.color == '#000000'):
                        pattern.color = 'white'
            self.objColor = 'white'

    def about(self):
        QtWidgets.QMessageBox.about(
            self, 'About',
            '<font size="10">PeakPo</font><br><br>' +
            '<font size="4">A Visual Diffraction Analysis Tool </font><br><br>' +
            '<font size="4"> by S.-H. Dan Shim, SHDShim@gmail.com</font><br>' +
            'Arizona State University<br>' +
            'https://sites.google.com/site/shdshim/ <br><br>' +
            'WARNING. Use at your own risk. ' +
            'This is a free software and no support is provided.<br>' +
            'You may report bugs or send comments to Dan Shim.')

    def add_patterns(self):
        """ get files for waterfall plot """
        if self.Pattern is None:
            QtWidgets.QMessageBox.warning(
                self, "Warning",
                "Pick a base diffraction pattern first from the File menu.")
            return
        f_dum, ext = os.path.splitext(self.Pattern.fname)
        files = QtWidgets.QFileDialog.getOpenFileNames(
            self,
            "Choose additional data files", self.chi_path,
            "Data files (*%s)" % ext)[0]
        if files is None:
            return
        new_patterns = []
        for f in files:
            filename = str(f)
            pattern = PatternPeakPo()
            pattern.read_file(filename)
            pattern.wavelength = self.doubleSpinBox_SetWavelength.value()
            pattern.display = False
            bg_roi = [self.doubleSpinBox_Background_ROI_min.value(),
                      self.doubleSpinBox_Background_ROI_max.value()]
            bg_params = [self.spinBox_BGParam0.value(),
                         self.spinBox_BGParam1.value(),
                         self.spinBox_BGParam2.value()]
            pattern.get_chbg(bg_roi, bg_params, yshift=0)
            new_patterns.append(pattern)
        self.waterfallpatterns += new_patterns
        self._list_wfpatterns()
        i = 0
        for pattern in self.waterfallpatterns:
            if pattern.display:
                i += 1
        if i != 0:
            self.update_graph()

    def _list_wfpatterns(self):
        """show a list of jcpds in the list window of tab 3"""
        n_columns = 5
        n_rows = self.waterfallpatterns.__len__()  # count for number of jcpds
        self.tableWidget_wfPatterns.setColumnCount(n_columns)
        self.tableWidget_wfPatterns.setRowCount(n_rows)
        self.tableWidget_wfPatterns.horizontalHeader().setVisible(True)
        self.tableWidget_wfPatterns.setHorizontalHeaderLabels(
            ['', 'Name',
             'Color', 'Color change', 'Wavelength'])
        for row in range(n_rows):
            # column 0 - checkbox
            item0 = QtWidgets.QTableWidgetItem()
            item0.setFlags(QtCore.Qt.ItemIsUserCheckable |
                           QtCore.Qt.ItemIsEnabled)
            if self.waterfallpatterns[row].display:
                item0.setCheckState(QtCore.Qt.Checked)
            else:
                item0.setCheckState(QtCore.Qt.Unchecked)
            self.tableWidget_wfPatterns.setItem(row, 0, item0)
            # column 1 - name
            item1 = QtWidgets.QTableWidgetItem(
                os.path.basename(self.waterfallpatterns[row].fname))
            self.tableWidget_wfPatterns.setItem(row, 1, item1)
            # column 2 - color
            item2 = QtWidgets.QTableWidgetItem('    ')
            self.tableWidget_wfPatterns.setItem(row, 2, item2)
            # column 3 - color setup
            self.tableWidget_wfPatterns_pushButton_color = QtWidgets.QPushButton('change')
            self.tableWidget_wfPatterns.item(row, 2).setBackground(
                QtGui.QColor(self.waterfallpatterns[row].color))
            self.tableWidget_wfPatterns_pushButton_color.clicked.connect(
                self._wfPatterns_handle_ColorButtonClicked)
            self.tableWidget_wfPatterns.setCellWidget(
                row, 3,
                self.tableWidget_wfPatterns_pushButton_color)
            # column 4 - wavelength
            self.tableWidget_wfPatterns_doubleSpinBox_wavelength = QtWidgets.QDoubleSpinBox()
            self.tableWidget_wfPatterns_doubleSpinBox_wavelength.\
                setAlignment(
                    QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing |
                    QtCore.Qt.AlignVCenter)
            self.tableWidget_wfPatterns_doubleSpinBox_wavelength.\
                setMaximum(2.0)
            self.tableWidget_wfPatterns_doubleSpinBox_wavelength.\
                setSingleStep(0.0001)
            self.tableWidget_wfPatterns_doubleSpinBox_wavelength.\
                setDecimals(4)
            self.tableWidget_wfPatterns_doubleSpinBox_wavelength.\
                setProperty("value", self.waterfallpatterns[row].wavelength)
            self.tableWidget_wfPatterns_doubleSpinBox_wavelength.\
                valueChanged.connect(
                    self._wfPatterns_handle_doubleSpinBoxChanged)
            self.tableWidget_wfPatterns_doubleSpinBox_wavelength.\
                setStyle(SpinBoxFixStyle())
            self.tableWidget_wfPatterns.setCellWidget(
                row, 4,
                self.tableWidget_wfPatterns_doubleSpinBox_wavelength)
            self.tableWidget_wfPatterns_doubleSpinBox_wavelength.\
                setKeyboardTracking(False)
            self.tableWidget_wfPatterns_doubleSpinBox_wavelength.\
                setFocusPolicy(QtCore.Qt.StrongFocus)
        self.tableWidget_wfPatterns.resizeColumnsToContents()
#        self.tableWidget_wfPatterns.resizeRowsToContents()
        self.tableWidget_wfPatterns.itemClicked.connect(
            self._wfPatterns_handle_ItemClicked)
        i = 0
        for pattern in self.waterfallpatterns:
            if pattern.display:
                i += 1
        if i != 0:
            self.update_graph()

    def _wfPatterns_handle_doubleSpinBoxChanged(self, value):
        box = self.sender()
        index = self.tableWidget_wfPatterns.indexAt(box.pos())
        if index.isValid():
            idx = index.row()
            self.waterfallpatterns[idx].wavelength = value
            i = 0
            for pattern in self.waterfallpatterns:
                if pattern.display:
                    i += 1

    def _wfPatterns_handle_ColorButtonClicked(self):
        button = self.sender()
        index = self.tableWidget_wfPatterns.indexAt(button.pos())
        if index.isValid():
            idx = index.row()
            if index.column() == 3:
                color = QtWidgets.QColorDialog.getColor()
                if color.isValid():
                    self.tableWidget_wfPatterns.item(idx, 2).\
                        setBackground(color)
                    self.waterfallpatterns[idx].color = str(color.name())
                    i = 0
                    for pattern in self.waterfallpatterns:
                        if pattern.display:
                            i += 1
                    if i != 0:
                        self.update_graph()

    def _wfPatterns_handle_ItemClicked(self, item):
        if item.column() == 0:
            idx = item.row()
            if item.checkState() == QtCore.Qt.Checked:
                self.waterfallpatterns[idx].display = True
            elif item.checkState() == QtCore.Qt.Unchecked:
                self.waterfallpatterns[idx].display = False
            self.update_graph()
        else:
            return

    def load_jlist(self):
        """get existing jlist file from data folder"""
        fn_jlist = QtWidgets.QFileDialog.getOpenFileName(
            self, "Choose A Session File",
            self.chi_path, "(*.ppss)")[0]
        if fn_jlist == '':
            return
        self._load_session(fn_jlist, True)
        self.label_Jlist.setText('Jlist in: ' +
                                 os.path.basename(str(fn_jlist)))
        self._list_jcpds()
        self.update_graph()

    def remove_a_jcpds(self):
        reply = QtWidgets.QMessageBox.question(
            self, 'Message',
            'Are you sure you want to remove the highlighted JPCDSs?',
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.Yes)
        if reply == QtWidgets.QMessageBox.No:
            return
        # print self.tableWidget_JCPDS.selectedIndexes().__len__()
        idx_checked = []
        for item in self.tableWidget_JCPDS.selectedIndexes():
            if item.column() != 1:
                return
            else:
                idx_checked.append(item.row())
        # remove checked ones
        if idx_checked != []:
            idx_checked.reverse()
            for idx in idx_checked:
                self.jlist.remove(self.jlist[idx])
                self.tableWidget_JCPDS.removeRow(idx)
#        self._list_jcpds()
            self.update_graph()
        else:
            QtWidgets.QMessageBox.warning(
                self, 'Warning',
                'In order to remove, highlight the names.')

    def view_jcpds(self):
        if self.jlist == []:
            return
        idx_checked = []
        for item in self.tableWidget_JCPDS.selectedIndexes():
            if item.column() != 1:
                QtWidgets.QMessageBox.warning(
                    self, "Warning",
                    "Highlight the name of JCPDS to view")
                return
            else:
                idx_checked.append(item.row())
        if idx_checked.__len__() != 1:
            QtWidgets.QMessageBox.warning(
                self, "Warning", "Only one JCPDS card can be shown at a time.")
        else:
            textoutput = self.jlist[idx_checked[0]].make_TextOutput(
                self.doubleSpinBox_Pressure.value(),
                self.doubleSpinBox_Temperature.value())
            self.plainTextEdit_ViewJCPDS.setPlainText(textoutput)

    def _list_jcpds(self):
        """show jcpds cards in the QTableWidget"""
        n_columns = 11
        n_rows = self.jlist.__len__()  # count for number of jcpds
        self.tableWidget_JCPDS.setColumnCount(n_columns)
        self.tableWidget_JCPDS.setRowCount(n_rows)
        self.tableWidget_JCPDS.horizontalHeader().setVisible(True)
        self.tableWidget_JCPDS.verticalHeader().setVisible(True)
        self.tableWidget_JCPDS.setHorizontalHeaderLabels(
            ['', 'Name',
             'Color', 'Color Change', 'V0 Tweak', 'K0 Tweak', 'K0p Tweak',
             'alpha0 Tweak', 'b/a Tweak', 'c/a Tweak', 'Int Tweak'])
        for row in range(n_rows):
            # column 0 - checkbox
            item0 = QtWidgets.QTableWidgetItem()
            item0.setFlags(QtCore.Qt.ItemIsUserCheckable |
                           QtCore.Qt.ItemIsEnabled)
            if self.jlist[row].display:
                item0.setCheckState(QtCore.Qt.Checked)
            else:
                item0.setCheckState(QtCore.Qt.Unchecked)
            self.tableWidget_JCPDS.setItem(row, 0, item0)
            # column 1 - name
            item1 = QtWidgets.QTableWidgetItem(self.jlist[row].name)
            self.tableWidget_JCPDS.setItem(row, 1, item1)
            # column 2 - color
            item2 = QtWidgets.QTableWidgetItem('    ')
            self.tableWidget_JCPDS.setItem(row, 2, item2)
            # column 3 - color setup
            self.tableWidget_JCPDS_pushButton_color = QtWidgets.QPushButton('change')
            self.tableWidget_JCPDS.item(row, 2).setBackground(
                QtGui.QColor(self.jlist[row].color))
            self.tableWidget_JCPDS_pushButton_color.clicked.connect(
                self._jcpds_handle_ColorButtonClicked)
            self.tableWidget_JCPDS.setCellWidget(
                row, 3, self.tableWidget_JCPDS_pushButton_color)
            # column 4 - V0 tweak
            self.tableWidget_JCPDS_doubleSpinBox_V0twk = QtWidgets.QDoubleSpinBox()
            self.tableWidget_JCPDS_doubleSpinBox_V0twk.setAlignment(
                QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing |
                QtCore.Qt.AlignVCenter)
            self.tableWidget_JCPDS_doubleSpinBox_V0twk.setMaximum(2.0)
            self.tableWidget_JCPDS_doubleSpinBox_V0twk.setSingleStep(0.001)
            self.tableWidget_JCPDS_doubleSpinBox_V0twk.setDecimals(3)
            self.tableWidget_JCPDS_doubleSpinBox_V0twk.setProperty(
                "value", self.jlist[row].twk_v0)
            self.tableWidget_JCPDS_doubleSpinBox_V0twk.valueChanged.connect(
                self._jcpds_handle_doubleSpinBoxChanged)
            self.tableWidget_JCPDS_doubleSpinBox_V0twk.setStyle(
                SpinBoxFixStyle())
            self.tableWidget_JCPDS.setCellWidget(
                row, 4, self.tableWidget_JCPDS_doubleSpinBox_V0twk)
            self.tableWidget_JCPDS_doubleSpinBox_V0twk.setFocusPolicy(
                QtCore.Qt.StrongFocus)
            # column 5 - K0 tweak
            self.tableWidget_JCPDS_doubleSpinBox_K0twk = QtWidgets.QDoubleSpinBox()
            self.tableWidget_JCPDS_doubleSpinBox_K0twk.setAlignment(
                QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing |
                QtCore.Qt.AlignVCenter)
            self.tableWidget_JCPDS_doubleSpinBox_K0twk.setMaximum(2.0)
            self.tableWidget_JCPDS_doubleSpinBox_K0twk.setSingleStep(0.01)
            self.tableWidget_JCPDS_doubleSpinBox_K0twk.setDecimals(2)
            self.tableWidget_JCPDS_doubleSpinBox_K0twk.setProperty(
                "value", self.jlist[row].twk_k0)
            self.tableWidget_JCPDS_doubleSpinBox_K0twk.valueChanged.connect(
                self._jcpds_handle_doubleSpinBoxChanged)
            self.tableWidget_JCPDS_doubleSpinBox_K0twk.setStyle(
                SpinBoxFixStyle())
            self.tableWidget_JCPDS.setCellWidget(
                row, 5, self.tableWidget_JCPDS_doubleSpinBox_K0twk)
            self.tableWidget_JCPDS_doubleSpinBox_K0twk.setFocusPolicy(
                QtCore.Qt.StrongFocus)
            # column 6 - K0p tweak
            self.tableWidget_JCPDS_doubleSpinBox_K0ptwk = QtWidgets.QDoubleSpinBox()
            self.tableWidget_JCPDS_doubleSpinBox_K0ptwk.setAlignment(
                QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing |
                QtCore.Qt.AlignVCenter)
            self.tableWidget_JCPDS_doubleSpinBox_K0ptwk.setMaximum(2.0)
            self.tableWidget_JCPDS_doubleSpinBox_K0ptwk.setSingleStep(0.01)
            self.tableWidget_JCPDS_doubleSpinBox_K0ptwk.setDecimals(2)
            self.tableWidget_JCPDS_doubleSpinBox_K0ptwk.setProperty(
                "value", self.jlist[row].twk_k0p)
            self.tableWidget_JCPDS_doubleSpinBox_K0ptwk.valueChanged.\
                connect(self._jcpds_handle_doubleSpinBoxChanged)
            self.tableWidget_JCPDS_doubleSpinBox_K0ptwk.setStyle(
                SpinBoxFixStyle())
            self.tableWidget_JCPDS.setCellWidget(
                row, 6, self.tableWidget_JCPDS_doubleSpinBox_K0ptwk)
            self.tableWidget_JCPDS_doubleSpinBox_K0ptwk.setFocusPolicy(
                QtCore.Qt.StrongFocus)
            # column 7 - alpha0 tweak
            self.tableWidget_JCPDS_doubleSpinBox_alpha0twk = QtWidgets.QDoubleSpinBox()
            self.tableWidget_JCPDS_doubleSpinBox_alpha0twk.setAlignment(
                QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing |
                QtCore.Qt.AlignVCenter)
            self.tableWidget_JCPDS_doubleSpinBox_alpha0twk.setMaximum(2.0)
            self.tableWidget_JCPDS_doubleSpinBox_alpha0twk.setSingleStep(
                0.01)
            self.tableWidget_JCPDS_doubleSpinBox_alpha0twk.setDecimals(2)
            self.tableWidget_JCPDS_doubleSpinBox_alpha0twk.setProperty(
                "value", self.jlist[row].twk_thermal_expansion)
            self.tableWidget_JCPDS_doubleSpinBox_alpha0twk.valueChanged.\
                connect(self._jcpds_handle_doubleSpinBoxChanged)
            self.tableWidget_JCPDS_doubleSpinBox_alpha0twk.setStyle(
                SpinBoxFixStyle())
            self.tableWidget_JCPDS_doubleSpinBox_alpha0twk.setFocusPolicy(
                QtCore.Qt.StrongFocus)
            self.tableWidget_JCPDS.setCellWidget(
                row, 7, self.tableWidget_JCPDS_doubleSpinBox_alpha0twk)
            # column 8 - b/a tweak
            if (self.jlist[row].symmetry == 'cubic') or \
                    (self.jlist[row].symmetry == 'tetragonal') or \
                    (self.jlist[row].symmetry == 'hexagonal'):
                item8 = QtWidgets.QTableWidgetItem('')
                item8.setFlags(QtCore.Qt.ItemIsEnabled)
                self.tableWidget_JCPDS.setItem(row, 8, item8)
            else:
                self.tableWidget_JCPDS_doubleSpinBox_b_atwk = QtWidgets.QDoubleSpinBox()
                self.tableWidget_JCPDS_doubleSpinBox_b_atwk.setAlignment(
                    QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing |
                    QtCore.Qt.AlignVCenter)
                self.tableWidget_JCPDS_doubleSpinBox_b_atwk.setMaximum(2.0)
                self.tableWidget_JCPDS_doubleSpinBox_b_atwk.setSingleStep(
                    0.001)
                self.tableWidget_JCPDS_doubleSpinBox_b_atwk.setDecimals(3)
                self.tableWidget_JCPDS_doubleSpinBox_b_atwk.setProperty(
                    "value", self.jlist[row].twk_b_a)
                self.tableWidget_JCPDS_doubleSpinBox_b_atwk.valueChanged.\
                    connect(self._jcpds_handle_doubleSpinBoxChanged)
                self.tableWidget_JCPDS_doubleSpinBox_b_atwk.setStyle(
                    SpinBoxFixStyle())
                self.tableWidget_JCPDS.setCellWidget(
                    row, 8, self.tableWidget_JCPDS_doubleSpinBox_b_atwk)
                self.tableWidget_JCPDS_doubleSpinBox_b_atwk.\
                    setKeyboardTracking(False)
                self.tableWidget_JCPDS_doubleSpinBox_b_atwk.setFocusPolicy(
                    QtCore.Qt.StrongFocus)
            # column 9 - c/a tweak
            if (self.jlist[row].symmetry == 'cubic'):
                item9 = QtWidgets.QTableWidgetItem('')
                item9.setFlags(QtCore.Qt.ItemIsEnabled)
                self.tableWidget_JCPDS.setItem(row, 9, item9)
            else:
                self.tableWidget_JCPDS_doubleSpinBox_c_atwk = QtWidgets.QDoubleSpinBox()
                self.tableWidget_JCPDS_doubleSpinBox_c_atwk.setAlignment(
                    QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing |
                    QtCore.Qt.AlignVCenter)
                self.tableWidget_JCPDS_doubleSpinBox_c_atwk.setMaximum(2.0)
                self.tableWidget_JCPDS_doubleSpinBox_c_atwk.setSingleStep(
                    0.001)
                self.tableWidget_JCPDS_doubleSpinBox_c_atwk.setDecimals(3)
                self.tableWidget_JCPDS_doubleSpinBox_c_atwk.setProperty(
                    "value", self.jlist[row].twk_c_a)
                self.tableWidget_JCPDS_doubleSpinBox_c_atwk.valueChanged.\
                    connect(self._jcpds_handle_doubleSpinBoxChanged)
                self.tableWidget_JCPDS_doubleSpinBox_c_atwk.setStyle(
                    SpinBoxFixStyle())
                self.tableWidget_JCPDS.setCellWidget(
                    row, 9, self.tableWidget_JCPDS_doubleSpinBox_c_atwk)
                self.tableWidget_JCPDS_doubleSpinBox_c_atwk.\
                    setKeyboardTracking(False)
                self.tableWidget_JCPDS_doubleSpinBox_c_atwk.setFocusPolicy(
                    QtCore.Qt.StrongFocus)
            # column 10 - int tweak
            self.tableWidget_JCPDS_doubleSpinBox_inttwk = QtWidgets.QDoubleSpinBox()
            self.tableWidget_JCPDS_doubleSpinBox_inttwk.setAlignment(
                QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing |
                QtCore.Qt.AlignVCenter)
            self.tableWidget_JCPDS_doubleSpinBox_inttwk.setMaximum(1.0)
            self.tableWidget_JCPDS_doubleSpinBox_inttwk.setSingleStep(0.05)
            self.tableWidget_JCPDS_doubleSpinBox_inttwk.setDecimals(2)
            self.tableWidget_JCPDS_doubleSpinBox_inttwk.setProperty(
                "value", self.jlist[row].twk_int)
            self.tableWidget_JCPDS_doubleSpinBox_inttwk.valueChanged.\
                connect(self._jcpds_handle_doubleSpinBoxChanged)
            self.tableWidget_JCPDS_doubleSpinBox_inttwk.setStyle(
                SpinBoxFixStyle())
            self.tableWidget_JCPDS.setCellWidget(
                row, 10, self.tableWidget_JCPDS_doubleSpinBox_inttwk)
            self.tableWidget_JCPDS_doubleSpinBox_inttwk.setFocusPolicy(
                QtCore.Qt.StrongFocus)
            self.tableWidget_JCPDS_doubleSpinBox_alpha0twk.\
                setKeyboardTracking(False)
            self.tableWidget_JCPDS_doubleSpinBox_inttwk.\
                setKeyboardTracking(False)
            self.tableWidget_JCPDS_doubleSpinBox_K0ptwk.\
                setKeyboardTracking(False)
            self.tableWidget_JCPDS_doubleSpinBox_K0twk.\
                setKeyboardTracking(False)
            self.tableWidget_JCPDS_doubleSpinBox_V0twk.\
                setKeyboardTracking(False)
        self.tableWidget_JCPDS.resizeColumnsToContents()
#        self.tableWidget_JCPDS.resizeRowsToContents()
        self.tableWidget_JCPDS.itemClicked.connect(
            self._jcpds_handle_ItemClicked)

    def _jcpds_handle_doubleSpinBoxChanged(self, value):
        box = self.sender()
        index = self.tableWidget_JCPDS.indexAt(box.pos())
        if index.isValid():
            idx = index.row()
            if index.column() == 4:
                self.jlist[idx].twk_v0 = value
            elif index.column() == 5:
                self.jlist[idx].twk_k0 = value
            elif index.column() == 6:
                self.jlist[idx].twk_k0p = value
            elif index.column() == 7:
                self.jlist[idx].twk_thermal_expansion = value
            elif index.column() == 8:
                self.jlist[idx].twk_b_a = value
            elif index.column() == 9:
                self.jlist[idx].twk_c_a = value
            elif index.column() == 10:
                self.jlist[idx].twk_int = value
            if self.jlist[idx].display:
                self.update_graph()

    def _jcpds_handle_ColorButtonClicked(self):
        button = self.sender()
        index = self.tableWidget_JCPDS.indexAt(button.pos())
        if index.isValid():
            idx = index.row()
            if index.column() == 3:
                color = QtWidgets.QColorDialog.getColor()
                if color.isValid():
                    self.tableWidget_JCPDS.item(idx, 2).setBackground(color)
                    self.jlist[idx].color = str(color.name())
                    self.update_graph()

    def _jcpds_handle_ItemClicked(self, item):
        if item.column() == 0:
            idx = item.row()
            if (item.checkState() == QtCore.Qt.Checked) ==\
                    self.jlist[idx].display:
                return
            if item.checkState() == QtCore.Qt.Checked:
                self.jlist[idx].display = True
            elif item.checkState() == QtCore.Qt.Unchecked:
                self.jlist[idx].display = False
            self.update_graph()
        else:
            return

    def make_jlist(self, append=False):
        """collect files for jlist"""
        files = QtWidgets.QFileDialog.getOpenFileNames(
            self, "Choose JPCDS Files", self.jcpds_path, "(*.jcpds)")[0]
        if files == []:
            return
        # reset jcpds_path
        self.jcpds_path, dum = os.path.split(str(files[0]))
        # construct jlist and assign default values
        jlist = []
#        for f, c in zip(files, colors.cnames):
#        n_files = files.__len__()
        n_color = 9
        jet = plt.get_cmap('gist_rainbow')
        cNorm = colors.Normalize(vmin=0, vmax=n_color)
        val = range(n_color)
        scalarMap = cmx.ScalarMappable(norm=cNorm, cmap=jet)
        values = [val[0], val[3], val[6], val[1], val[4], val[7], val[2],
                  val[5], val[8]]
        if append:
            n_existingjcpds = self.jlist.__len__()
            n_addedjcpds = files.__len__()
            if ((n_existingjcpds + n_addedjcpds) > n_color):
                i = 0
            else:
                i = n_existingjcpds
        else:
            i = 0
        for f in files:
            phase = JCPDSplt()
            phase.read_file(str(f))  # phase.file = f
            phase.color = colors.rgb2hex(scalarMap.to_rgba(values[i]))
            jlist.append(phase)
            i += 1
        if append:
            self.jlist += jlist
        else:  # initiate self.jlist
            self.jlist = []
            self.jlist = jlist
        # display on the QTableWidget
        self._list_jcpds()
        if self.Pattern is None:
            self.update_graph(limits=[0., 25., 0., 100.])
        else:
            self.update_graph()

    def read_plot(self, event):
        if self.mpl.ntb._active is not None:
            return
        if (event.xdata is None) or (event.ydata is None):
            return
        x_click = float(event.xdata)
        y_click = float(event.ydata)
        x_click_dsp = self.doubleSpinBox_SetWavelength.value() / 2. / \
            np.sin(np.radians(x_click / 2.))
        clicked_position = "Clicked position: {0: 10.4f}, {1: 7.1f}, \n dsp = {2: 10.4f} A".\
            format(x_click, y_click, x_click_dsp)
        if (self.jlist == []) and (self.ucfitlist == []):
            QtWidgets.QMessageBox.warning(self, "Information",
                                          clicked_position)
        else:
            # get jcpds information
            x_find = event.xdata
            textinfo = self._find_closestjcpds(x_find)
            QtWidgets.QMessageBox.warning(self, "Information",
                                          clicked_position + '\n' + textinfo)

    def _find_closestjcpds(self, x):
        jcount = 0
        for j in self.jlist:
            if j.display:
                jcount += 1
        ucount = 0
        for u in self.ucfitlist:
            if u.display:
                ucount += 1
        if (jcount + ucount) == 0:
            return ''
        if jcount != 0:
            idx_j = []
            diff_j = []
            tth_j = []
            h_j = []
            k_j = []
            l_j = []
            names_j = []
            dsp_j = []
            int_j = []
            for j in self.jlist:
                if j.display:
                    i, d, t = j.find_DiffLine(
                        x, self.doubleSpinBox_SetWavelength.value())
                    idx_j.append(i)
                    diff_j.append(d)
                    tth_j.append(t)
                    h_j.append(j.DiffLines[i].h)
                    k_j.append(j.DiffLines[i].k)
                    l_j.append(j.DiffLines[i].l)
                    dsp_j.append(j.DiffLines[i].dsp)
                    int_j.append(j.DiffLines[i].intensity)
                    names_j.append(j.name)
        if ucount != 0:
            idx_u = []
            diff_u = []
            tth_u = []
            h_u = []
            k_u = []
            l_u = []
            names_u = []
            dsp_u = []
            int_u = []
            for u in self.ucfitlist:
                if u.display:
                    i, d, t = u.find_DiffLine(
                        x, self.doubleSpinBox_SetWavelength.value())
                    idx_u.append(i)
                    diff_u.append(d)
                    tth_u.append(t)
                    h_u.append(u.DiffLines[i].h)
                    k_u.append(u.DiffLines[i].k)
                    l_u.append(u.DiffLines[i].l)
                    dsp_u.append(u.DiffLines[i].dsp)
                    int_u.append(u.DiffLines[i].intensity)
                    names_u.append(u.name)
        if (jcount != 0) and (ucount == 0):
            idx_min = diff_j.index(min(diff_j))
            tth_min = tth_j[idx_min]
            dsp_min = dsp_j[idx_min]
            int_min = int_j[idx_min]
            h_min = h_j[idx_min]
            k_min = k_j[idx_min]
            l_min = l_j[idx_min]
            name_min = names_j[idx_min]
        elif (jcount == 0) and (ucount != 0):
            idx_min = diff_u.index(min(diff_u))
            tth_min = tth_u[idx_min]
            dsp_min = dsp_u[idx_min]
            int_min = int_u[idx_min]
            h_min = h_u[idx_min]
            k_min = k_u[idx_min]
            l_min = l_u[idx_min]
            name_min = names_u[idx_min]
        else:
            if min(diff_j) <= min(diff_u):
                idx_min = diff_j.index(min(diff_j))
                tth_min = tth_j[idx_min]
                dsp_min = dsp_j[idx_min]
                int_min = int_j[idx_min]
                h_min = h_j[idx_min]
                k_min = k_j[idx_min]
                l_min = l_j[idx_min]
                name_min = names_j[idx_min]
            else:
                idx_min = diff_u.index(min(diff_u))
                tth_min = tth_u[idx_min]
                dsp_min = dsp_u[idx_min]
                int_min = int_u[idx_min]
                h_min = h_u[idx_min]
                k_min = k_u[idx_min]
                l_min = l_u[idx_min]
                name_min = names_u[idx_min]
        line1 = 'Two theta = {0: 10.4f}, d-spacing = {1: 10.4f} A'.format(
            float(tth_min), float(dsp_min))
        line2 = 'intensity = {0: 5.0f}, hkl = {1: 3.0f} {2: 3.0f} {3: 3.0f}'.\
            format(int(int_min), int(h_min), int(k_min), int(l_min))
        textoutput = name_min + '\n' + line1 + '\n' + line2
        return textoutput

    def erase_waterfall(self):
        self.waterfallpatterns = []
        self.tableWidget_wfPatterns.clearContents()
        self.update_graph()

    def remove_waterfall(self):
        reply = QtWidgets.QMessageBox.question(
            self, 'Message',
            'Are you sure you want to remove the highlighted pattern?',
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.Yes)
        if reply == QtWidgets.QMessageBox.No:
            return
        # print self.tableWidget_JCPDS.selectedIndexes().__len__()
        idx_checked = []
        for item in self.tableWidget_wfPatterns.selectedIndexes():
            if item.column() != 1:
                return
            else:
                idx_checked.append(item.row())
        # remove checked ones
        if idx_checked != []:
            idx_checked.reverse()
            for idx in idx_checked:
                self.waterfallpatterns.remove(self.waterfallpatterns[idx])
                self.tableWidget_wfPatterns.removeRow(idx)
#        self._list_jcpds()
            self.update_graph()
        else:
            QtWidgets.QMessageBox.warning(
                self, 'Warning', 'In order to remove, highlight the names.')

    def up_waterfall(self):
        # get selected cell number
        idx_selected = self._find_a_wf()
        if idx_selected is None:
            QtWidgets.QMessageBox.warning(self, "Warning",
                                          "Highlight the item to move first.")
            return
        i = idx_selected
        self.waterfallpatterns[i - 1], self.waterfallpatterns[i] = \
            self.waterfallpatterns[i], self.waterfallpatterns[i - 1]
        self.tableWidget_wfPatterns.setCurrentItem(
            self.tableWidget_wfPatterns.item(i - 1, 1))
        """
        self.tableWidget_wfPatterns.setItemSelected(
            self.tableWidget_wfPatterns.item(i - 1, 1), True)
        self.tableWidget_wfPatterns.setItemSelected(
            self.tableWidget_wfPatterns.item(i, 1), False)
        """
        self._list_wfpatterns()

    def down_waterfall(self):
        # get selected cell number
        idx_selected = self._find_a_wf()
        if idx_selected is None:
            QtWidgets.QMessageBox.warning(self, "Warning",
                                          "Highlight the item to move first.")
            return
        i = idx_selected
        self.waterfallpatterns[i + 1], self.waterfallpatterns[i] = \
            self.waterfallpatterns[i], self.waterfallpatterns[i + 1]
        self.tableWidget_wfPatterns.setCurrentItem(
            self.tableWidget_wfPatterns.item(i + 1, 1))
        """
        self.tableWidget_wfPatterns.setItemSelected(
            self.tableWidget_wfPatterns.item(i + 1, 1), True)
        self.tableWidget_wfPatterns.setItemSelected(
            self.tableWidget_wfPatterns.item(i, 1), False)
        """
        self._list_wfpatterns()

    def apply_changestograph(self, value):
        self.update_graph()

    def apply_wavelength(self):
        # self.wavelength = value
        self.Pattern.wavelength = self.doubleSpinBox_SetWavelength.value()
        self.update_graph()

    def update_bgsub(self):
        '''this is only to read the current inputs and replot'''
        if self.Pattern is None:
            QtWidgets.QMessageBox.warning(
                self, "Warning",
                "Choose a base pattern first from the File menu.")
            return
        """receive new bg parameters and update the graph"""
        bg_params = [self.spinBox_BGParam0.value(),
                     self.spinBox_BGParam1.value(),
                     self.spinBox_BGParam2.value()]
        bg_roi = [self.doubleSpinBox_Background_ROI_min.value(),
                  self.doubleSpinBox_Background_ROI_max.value()]
        self.Pattern.subtract_bg(bg_roi, bg_params, yshift=0)
        if self.waterfallpatterns != []:
            for pattern in self.waterfallpatterns:
                pattern.subtract_bg(bg_roi, bg_params, yshift=0)
        self.update_graph2whole()

    def reset_bgsub(self):
        '''this is to read from session file and put to the table'''
        bg_params = [self.spinBox_BGParam0.value(),
                     self.spinBox_BGParam1.value(),
                     self.spinBox_BGParam2.value()]
        bg_roi = [self.doubleSpinBox_Background_ROI_min.value(),
                  self.doubleSpinBox_Background_ROI_max.value()]
        self.Pattern.subtract_bg(bg_roi, bg_params, yshift=0)
        if self.waterfallpatterns != []:
            for pattern in self.waterfallpatterns:
                pattern.get_chbg(bg_roi, bg_params, yshift=0)

    def update_graph2whole(self):
        if self.Pattern is None:
            return
        if self.ntb_Bgsub.isChecked():
            x, y = self.Pattern.get_bgsub()
        else:
            x, y = self.Pattern.get_raw()
        self.update_graph(limits=[x.min(), x.max(), y.min(), y.max()])

    def apply_PTtoGraph(self):
        if self.jlist != []:
            self.update_graph()

    def set_temperature(self, temperature=None):
        self.doubleSpinBox_Temperature.setValue(temperature)
#        if self.jlist != []:
#            self.update_graph()

    def set_pstep(self, value):
        if self.radioButton_P01.isChecked():
            value = 0.1
        elif self.radioButton_P10.isChecked():
            value = 10.
        elif self.radioButton_P100.isChecked():
            value = 100.
        else:
            value = 1.
        self.doubleSpinBox_Pressure.setSingleStep(value)

    def set_tstep(self, value):
        if self.radioButton_T1.isChecked():
            value = 1.
        elif self.radioButton_T10.isChecked():
            value = 10.
        elif self.radioButton_T1000.isChecked():
            value = 1000.
        else:
            value = 100.
        self.doubleSpinBox_Temperature.setSingleStep(value)

    ###########################################################################
    # base pattern control
    def _read_a_newpattern(self, new_filename):
        self.Pattern = PatternPeakPo()
        self.Pattern.read_file(new_filename)
        self.Pattern.wavelength = self.doubleSpinBox_SetWavelength.value()
        self.Pattern.display = True
        self.label_DiffractionPatternFileName.setText('1D Pattern: ' +
                                                      self.Pattern.fname)
        x_raw, y_raw = self.Pattern.get_raw()
        if (x_raw.min() >=
            self.doubleSpinBox_Background_ROI_min.value()) or\
                (x_raw.max() <=
                    self.doubleSpinBox_Background_ROI_min.value()):
            self.doubleSpinBox_Background_ROI_min.setValue(x_raw.min())
        if (x_raw.max() <=
            self.doubleSpinBox_Background_ROI_max.value()) or\
                (x_raw.min() >=
                    self.doubleSpinBox_Background_ROI_max.value()):
            self.doubleSpinBox_Background_ROI_max.setValue(x_raw.max())
        self.Pattern.subtract_bg(
            [self.doubleSpinBox_Background_ROI_min.value(),
                self.doubleSpinBox_Background_ROI_max.value()],
            [self.spinBox_BGParam0.value(),
                self.spinBox_BGParam1.value(),
                self.spinBox_BGParam2.value()], yshift=0)
        if self.pushButton_AddRemoveCake.isChecked() and \
                self.poni_filename is not None:
            self.addremove_Cake()
            # self._load_new_image()
            # self._update_cake()

    def select_file(self):
        """
        opens a file select dialog

        2017/06/10 remove support for other file formats than chi
        """
        file = QtWidgets.QFileDialog.getOpenFileName(
            self, "Open a Chi File", self.chi_path, "Data files (*.chi)")[0]
        chi_path, dum = os.path.split(str(file))
        if os.path.exists(str(file)):
            self.chi_path = chi_path
            if self.Pattern is not None:
                old_filename = self.Pattern.fname
            else:
                old_filename = ''
            new_filename = str(file)
            self._read_a_newpattern(new_filename)
            if old_filename == '':
                self.update_graph2whole()
            else:
                self.update_graph()

    def goto_nextfile(self, move):
        """quick move to the next file"""
        if self.Pattern is None:
            QtWidgets.QMessageBox.warning(
                self, "Warning", "Choose a base pattern first.")
            return
        filelist = get_sorted_filelist(
            self.chi_path,
            sorted_by_name=self.radioButton_SortbyNme.isChecked())
        idx = find_from_filelist(filelist, self.Pattern.fname)
        if idx == -1:
            QtWidgets.QMessageBox.warning(
                self, "Warning", "Cannot find current file")
        if self.radioButton_FileStep1.isChecked():
            step = 1
        else:
            step = 10
        if move == 'next':
            idx_new = idx + step
        elif move == 'previous':
            idx_new = idx - step
        elif move == 'last':
            idx_new = filelist.__len__() - 1
        elif move == 'first':
            idx_new = 0
        if idx_new > filelist.__len__() - 1:
            idx_new = filelist.__len__() - 1
        if idx_new < 0:
            idx_new = 0
        new_filename = filelist[idx_new]
        if os.path.exists(new_filename):
            self._read_a_newpattern(new_filename)
            self.Pattern.color = self.objColor
            # Turn off the option below during synchrotron.  Not helping much.
            # self._update_session()
            self.update_graph()
        else:
            QtWidgets.QMessageBox.warning(self, "Warning",
                                          new_filename + " does not exist.")

    def update_graph(self, limits=None):
        """Updates the graph"""
        t_start = time.time()
        self.setCursor(QtCore.Qt.WaitCursor)
        if limits is None:
            lims = self.mpl.canvas.ax.axis()
            limits = lims
        if (self.Pattern is None) and (self.jlist == []):
            return
        if self.pushButton_AddRemoveCake.isChecked():
            self.mpl.canvas.resize_axes(self.spinBox_CakeAxisSize.value())
        else:
            self.mpl.canvas.resize_axes(1)
            self.mpl.canvas.ax_bottom.tick_params(
                axis='y', colors=self.objColor, labelleft=False)
            self.mpl.canvas.ax_bottom.spines['right'].set_visible(False)
            self.mpl.canvas.ax_bottom.spines['left'].set_visible(False)
            self.mpl.canvas.ax_bottom.spines['top'].set_visible(False)
            self.mpl.canvas.ax_bottom.spines['bottom'].set_visible(False)
        self._set_NightDayView()
        # diff file only
        if self.Pattern is not None:
            self.mpl.canvas.fig.suptitle(self.Pattern.fname,
                                         color=self.objColor, fontsize=16)
            self._plot_diffpattern()
            if self.waterfallpatterns != []:
                self._plot_waterfallpatterns()
        # jcpds only
        if (self.jlist != []):
            self._plot_jcpds()
        if (self.ucfitlist != []):
            self._plot_ucfit()

        self.mpl.canvas.ax.set_xlim(limits[0], limits[1])
        if not self.ntb_ResetY.isChecked():
            self.mpl.canvas.ax.set_ylim(limits[2], limits[3])
        x_size = limits[1] - limits[0]
        if x_size <= 50.:
            majortick_interval = 1
            minortick_interval = 0.1
        else:
            majortick_interval = 10
            minortick_interval = 1
        xlabel = 'Two Theta (Degrees), ' + \
            "{0: 5.1f} GPa, {1: 4.0f} K, {2: 6.4f} A".\
            format(self.doubleSpinBox_Pressure.value(),
                   self.doubleSpinBox_Temperature.value(),
                   self.doubleSpinBox_SetWavelength.value())
        self.mpl.canvas.ax.set_xlabel(xlabel)
        # cake only
        if self.pushButton_AddRemoveCake.isChecked():
            self._plot_cake()
            self.mpl.canvas.ax_bottom.set_ylabel("Azimuthal angle (degrees)")
        self.mpl.canvas.ax.set_ylabel('Intensity (arbitrary unit)')
        self.mpl.canvas.ax.autoscale(enable=False, axis=u'both', tight=True)
        majorLocator = MultipleLocator(majortick_interval)
        minorLocator = MultipleLocator(minortick_interval)
        self.mpl.canvas.ax.xaxis.set_major_locator(majorLocator)
        self.mpl.canvas.ax.xaxis.set_minor_locator(minorLocator)
        # Note that the line below takes most time.
        # slow plotting is just because I use matplotlib.
        self.mpl.canvas.draw()
        print("Plot takes: {0:.4f} s at {1: .2f}".format(time.time() -
                                                         t_start, time.time()))
        self.unsetCursor()

    def _plot_ucfit(self):
        i = 0
        for j in self.ucfitlist:
            if j.display:
                i += 1
        if i == 0:
            return
        bottom, ymax = self.mpl.canvas.ax.get_ylim()
        bar_scale = 1. / 100. * ymax
        i = 0
        for j in self.ucfitlist:
            if j.display:
                j.cal_dsp()
                tth, inten = j.get_tthVSint(
                    self.doubleSpinBox_SetWavelength.value())
                bar_min = np.ones(tth.shape) * bottom
                intensity = inten
                bar_min = np.ones(tth.shape) * bottom
                self.tableWidget_UnitCell.removeCellWidget(i, 4)
                Item4 = QtWidgets.QTableWidgetItem(
                    "{:.3f}".format(float(j.v)))
                Item4.setFlags(QtCore.Qt.ItemIsSelectable |
                               QtCore.Qt.ItemIsEnabled)
                self.tableWidget_UnitCell.setItem(i, 4, Item4)
                if self.checkBox_Intensity.isChecked():
                    self.mpl.canvas.ax.vlines(tth, bar_min, intensity *
                                              bar_scale, colors=j.color)
                else:
                    self.mpl.canvas.ax.vlines(tth, bar_min, 100. * bar_scale,
                                              colors=j.color)
            else:
                pass
            i += 1

    def _plot_cake(self):
        # t_start = time.time()
        clim = (self.spinBox_VMin.value(), self.spinBox_VMax.value())
        self.mpl.canvas.ax_bottom.imshow(
            self.intensity_cake, origin="lower",
            extent=[self.tth_cake.min(), self.tth_cake.max(),
                    self.chi_cake.min(), self.chi_cake.max()],
            aspect="auto", cmap="gray_r", clim=clim)
        # print("Cake plot takes: %.4f second" % (time.time() - t_start))

    def _plot_jcpds(self):
        # t_start = time.time()
        i = 0
        for j in self.jlist:
            if j.display:
                i += 1
        if i == 0:
            return
        # Reading ylim after zoom pan is not possible
        # lims = self.mpl.canvas.ax.axis()
        # bar_scale = 1./100. * lims[3]
        # bottom = lims[2]
        bottom, ymax = self.mpl.canvas.ax.get_ylim()
        bar_scale = 1. / 100. * ymax
        for j in self.jlist:
            if j.display:
                j.cal_dsp(self.doubleSpinBox_Pressure.value(),
                          self.doubleSpinBox_Temperature.value())
                tth, inten = j.get_tthVSint(
                    self.doubleSpinBox_SetWavelength.value())
                intensity = inten * j.twk_int
                bar_min = np.ones(tth.shape) * bottom
                if self.checkBox_Intensity.isChecked():
                    self.mpl.canvas.ax.vlines(
                        tth, bar_min, intensity * bar_scale,
                        colors=j.color, label=j.name + (", %.3f A^3" % j.v))
                else:
                    self.mpl.canvas.ax.vlines(
                        tth, bar_min, 100. * bar_scale,
                        colors=j.color, label=j.name + (", %.3f A^3" % j.v))
                if self.pushButton_AddRemoveCake.isChecked():
                    for tth_i in tth:
                        self.mpl.canvas.ax_bottom.axvline(
                            x=tth_i, color=j.color, lw=0.5)
            else:
                pass
        leg_j = self.mpl.canvas.ax.legend(loc=1, prop={'size': 10},
                                          framealpha=0., handlelength=1)

        for line, txt in zip(leg_j.get_lines(), leg_j.get_texts()):
            txt.set_color(line.get_color())
        # print("JCPDS plot takes: %.4f second" % (time.time() - t_start))

    def _plot_waterfallpatterns(self):
        # t_start = time.time()
        # count how many are dispaly
        i = 0
        for pattern in self.waterfallpatterns:
            if pattern.display:
                i += 1
        if i == 0:
            return
        j = 0  # this is needed for waterfall gaps
        # get y_max
        for pattern in self.waterfallpatterns:
            if pattern.display:
                j += 1
                self.mpl.canvas.ax.text(0.01, 0.97 - i * 0.03 + j * 0.03,
                                        os.path.basename(pattern.fname),
                                        transform=self.mpl.canvas.ax.transAxes,
                                        color=pattern.color)
                if self.ntb_Bgsub.isChecked():
                    ygap = self.doubleSpinBox_WaterfallGaps.value() * \
                        self.Pattern.y_bgsub.max() * float(j)
                    if self.checkBox_BasePtnBackground.isChecked() and \
                            np.array_equal(pattern.x_raw, self.Pattern.x_raw):
                        y_bgsub = pattern.y_bgsub + pattern.y_bg - \
                            self.Pattern.y_bg
                    else:
                        y_bgsub = pattern.y_bgsub
                    if self.checkBox_IntNorm.isChecked():
                        y = y_bgsub / y_bgsub.max() * \
                            self.Pattern.y_bgsub.max()
                    else:
                        y = y_bgsub
                    x_t = pattern.x_bgsub
                else:
                    ygap = self.doubleSpinBox_WaterfallGaps.value() * \
                        self.Pattern.y_raw.max() * float(j)
                    if self.checkBox_IntNorm.isChecked():
                        y = pattern.y_raw / pattern.y_raw.max() *\
                            self.Pattern.y_raw.max()
                    else:
                        y = pattern.y_raw
                    x_t = pattern.x_raw
                if self.checkBox_SetToBasePtnLambda.isChecked():
                    x = convert_tth(x_t, pattern.wavelength,
                                    self.Pattern.wavelength)
                else:
                    x = x_t
                self.mpl.canvas.ax.plot(x, y + ygap, c=pattern.color)
        self.mpl.canvas.ax.text(0.01, 0.97 - i * 0.03,
                                os.path.basename(self.Pattern.fname),
                                transform=self.mpl.canvas.ax.transAxes,
                                color=self.Pattern.color)
        # print("Waterfall plot takes: %.4f second" % (time.time() - t_start))

#        if j != 0:
#            leg_wf = self.mpl.canvas.ax.legend(loc=2, prop={'size':10}, \
#                        framealpha=0., handlelength=1)
#            for line, txt in zip(leg_wf.get_lines(), leg_wf.get_texts()):
#                txt.set_color(line.get_color())

    def _plot_diffpattern(self):
        if self.ntb_Bgsub.isChecked():
            x, y = self.Pattern.get_bgsub()
            self.mpl.canvas.ax.plot(x, y, c=self.Pattern.color)
        else:
            x, y = self.Pattern.get_raw()
            self.mpl.canvas.ax.plot(x, y, c=self.Pattern.color)
            x_bg, y_bg = self.Pattern.get_background()
            self.mpl.canvas.ax.plot(x_bg, y_bg, c=self.Pattern.color, lw=0.5)
